<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoloMeet VR - Ultimate Executive Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>

    <style>
        :root { --neon: #00f3ff; --neon-red: #ff3333; --neon-green: #00ff88; }
        body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', monospace; color: var(--neon); }
        
        /* HUD Hologr√°fico (Estilo Premium) */
        #hud { 
            position: fixed; inset: 0; pointer-events: none; padding: 25px; z-index: 100;
            display: flex; flex-direction: column; justify-content: space-between;
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.4) 100%);
        }
        
        /* Efecto de l√≠neas de escaneo (Scanlines) */
        #hud::before {
            content: " "; position: fixed; inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 3px, 3px 100%; pointer-events: none;
            z-index: -1;
        }

        .panel { 
            background: rgba(0, 15, 30, 0.85); border: 1px solid var(--neon); 
            padding: 15px; backdrop-filter: blur(12px); pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.15); border-radius: 2px;
            text-transform: uppercase; letter-spacing: 1px;
        }

        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; }
        #timer-display { font-size: 28px; font-weight: bold; color: var(--neon); text-shadow: 0 0 10px var(--neon); }
        
        button { 
            background: transparent; color: var(--neon); border: 1px solid var(--neon); 
            padding: 8px 15px; cursor: pointer; font-weight: bold; font-size: 10px;
            transition: all 0.3s; margin: 2px;
        }
        button:hover { background: var(--neon); color: #000; box-shadow: 0 0 15px var(--neon); }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        
        #chat-box { width: 320px; height: 250px; display: flex; flex-direction: column; }
        #messages { flex: 1; overflow-y: auto; font-size: 11px; margin-bottom: 10px; padding-right: 5px; }
        input { background: rgba(0,0,0,0.5); border: 1px solid #004444; color: #fff; padding: 8px; width: 100%; }
        
        /* Modal de Bienvenida */
        #welcome-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 1000;
            display: flex; align-items: center; justify-content: center; text-align: center;
        }
        .welcome-content {
            background: rgba(5, 10, 20, 0.95); border: 2px solid var(--neon);
            padding: 40px; max-width: 500px;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.3); border-radius: 4px;
        }
        .welcome-content h1 { color: var(--neon); margin-bottom: 20px; font-size: 28px; }
        .welcome-content p { color: #ccc; margin-bottom: 15px; line-height: 1.6; text-align: left; }
        .welcome-content ul { color: #ccc; text-align: left; margin-bottom: 25px; padding-left: 20px; }
        .welcome-content li { margin-bottom: 8px; }
        #enter-btn {
            background: linear-gradient(135deg, var(--neon), #0088ff); color: #000;
            padding: 15px 40px; font-size: 16px; border: none;
        }
        #enter-btn:hover { box-shadow: 0 0 30px var(--neon); transform: scale(1.05); }
        
        /* Indicador de hablando */
        .speaking-indicator {
            position: absolute; width: 20px; height: 20px;
            background: var(--neon-green); border-radius: 50%;
            box-shadow: 0 0 15px var(--neon-green); animation: speakingPulse 0.5s infinite;
            pointer-events: none; display: none;
        }
        @keyframes speakingPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.8; }
        }
        
        /* Cursor interactivo para YouTube */
        .youtube-active .webgl-canvas { pointer-events: none !important; }
        .youtube-active .css3d-canvas { pointer-events: auto !important; }
        
        /* Mensaje de video bloqueado */
        .yt-blocked-message {
            position: absolute; inset: 0; background: rgba(20, 20, 20, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--neon-red); text-align: center; padding: 20px;
        }
        .yt-blocked-message h3 { color: var(--neon-red); margin-bottom: 15px; }
        .yt-blocked-message p { color: #ccc; max-width: 400px; line-height: 1.5; }
        .yt-blocked-message button { margin-top: 20px; background: var(--neon-red); color: #000; border: none; }
        
        #pdf-canvas { display: none; }
    </style>
</head>
<body>

<div id="welcome-modal">
    <div class="welcome-content">
        <h1>HoloMeet VR</h1>
        <p>Bienvenido a la sala de videoconferencias inmersiva. Antes de continuar:</p>
        <ul>
            <li>üé§ Usa auriculares para evitar eco y feedback de audio</li>
            <li>üåê Comparte el ID de sala con tus participantes</li>
            <li>üì∫ Para videos de YouTube, usa enlaces p√∫blicos</li>
            <li>‚è∞ Usa el temporizador para gestionar turnos</li>
        </ul>
        <button id="enter-btn" onclick="startApp()">ENTRAR A LA SALA</button>
    </div>
</div>

<div id="hud" style="display:none;">
    <div class="top-bar">
        <div class="panel">
            <div id="role-tag" style="font-size: 9px; margin-bottom: 5px; color: #888;">ESTADO DE RED</div>
            <div id="room-id" style="font-size: 14px; font-weight: bold;">ID: ---</div>
            <div id="user-count" style="font-size: 10px; margin-top: 5px; color: var(--neon);">üë• 1 participante</div>
        </div>
        
        <div class="panel" style="text-align:center;">
            <div style="font-size: 9px; opacity: 0.7;">CONTROL DE TURNO</div>
            <div id="timer-display">00:00</div>
            <div style="display:flex; gap:5px; justify-content: center; margin-top: 5px;">
                <button onclick="sendTimer(5)">5 MIN</button>
                <button onclick="sendTimer(10)">10 MIN</button>
                <button onclick="sendTimer(15)">15 MIN</button>
            </div>
        </div>

        <div id="chat-box" class="panel">
            <div id="messages"></div>
            <input type="text" id="chat-input" placeholder="Mensaje...">
        </div>
    </div>

    <div class="controls panel" style="display:flex; justify-content: center; gap: 20px; align-items: center; flex-wrap: wrap;">
        <div>
            <button onclick="document.getElementById('pdf-upload').click()">üìÇ PDF HD</button>
            <input type="file" id="pdf-upload" accept=".pdf" style="display:none">
        </div>
        
        <div style="display:flex; align-items:center; border-left: 1px solid #333; padding-left: 15px;">
            <button onclick="changePage(-1)">‚óÄ</button>
            <span id="page-num" style="margin: 0 15px; font-size: 14px; min-width: 80px; text-align:center;">PAG 1 / 1</span>
            <button onclick="changePage(1)">‚ñ∂</button>
        </div>

        <div style="border-left: 1px solid #333; padding-left: 15px; display:flex; gap:5px;">
            <input type="text" id="yt-url" placeholder="YouTube URL" style="width: 150px; font-size: 10px;">
            <button onclick="loadYT()">‚ñ∂ YT</button>
        </div>

        <div style="border-left: 1px solid #333; padding-left: 15px;">
            <button id="mic-btn" onclick="toggleMic()">üé§ OFF</button>
        </div>
        
        <button id="mute-all-btn" onclick="toggleMuteAll()" style="border-color: #ff8800; color: #ff8800;" disabled>üîá SILENCIAR</button>
        
        <button onclick="exportLog()" style="border-color: var(--neon-red); color: var(--neon-red);">üíæ LOG</button>
    </div>
</div>

<div id="container"></div>
<canvas id="pdf-canvas"></canvas>

<script>
    // --- CONFIGURACI√ìN VISUAL PREMIUM ---
    let scene, camera, renderer, composer, cssRenderer, dashboard, laserPoint;
    let peer, myConn, isHost = false, clientConns = [];
    let remoteAvatars = {};
    let pdfDoc = null, pageNum = 1, logs = [], timeLeft = 0;
    let audioContext = null, audioStream = null, isMuted = false;
    let youtubeVideoId = null, isYouTubeActive = false;
    
    const urlParams = new URLSearchParams(location.search);
    const roomName = urlParams.get('room') || 'DEMO';
    const ROOM_ID = 'HM-ULTIMATE-' + roomName;

    function init3D() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x020205, 5, 25);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.8, 7);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.domElement.classList.add('webgl-canvas');
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.pointerEvents = 'none';
        document.getElementById('container').appendChild(renderer.domElement);

        // CSS3D Renderer para YouTube
        cssRenderer = new THREE.CSS3DRenderer();
        cssRenderer.setSize(window.innerWidth, window.innerHeight);
        cssRenderer.domElement.classList.add('css3d-canvas');
        cssRenderer.domElement.style.position = 'absolute';
        cssRenderer.domElement.style.top = '0';
        cssRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(cssRenderer.domElement);

        // --- POST-PROCESAMIENTO (BLOOM/BRILLO) ---
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.21;
        bloomPass.strength = 1.2; // Intensidad del brillo ne√≥n
        bloomPass.radius = 0.55;

        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- MATERIALES PREMIUM ---
        const floorMat = new THREE.MeshPhysicalMaterial({ 
            color: 0x080808, metalness: 0.9, roughness: 0.1, 
            clearcoat: 1, clearcoatRoughness: 0.05, reflectivity: 1 
        });
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), floorMat);
        floor.rotation.x = -Math.PI/2;
        scene.add(floor);

        dashboard = new THREE.Mesh(
            new THREE.PlaneGeometry(6.4, 3.6),
            new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
        );
        dashboard.position.set(0, 2.6, -4);
        scene.add(dashboard);

        // Marco de la pantalla
        const frame = new THREE.Mesh(
            new THREE.BoxGeometry(6.8, 4.0, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.2 })
        );
        frame.position.set(0, 2.6, -4.1);
        scene.add(frame);

        // L√°ser Ne√≥n
        laserPoint = new THREE.Mesh(
            new THREE.SphereGeometry(0.04),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        laserPoint.visible = false;
        scene.add(laserPoint);

        // Iluminaci√≥n Pro
        const ambient = new THREE.HemisphereLight(0x00f3ff, 0x000000, 0.4);
        scene.add(ambient);
        
        const rectLight = new THREE.RectAreaLight(0x00f3ff, 5, 10, 10);
        rectLight.position.set(0, 5, -2);
        rectLight.lookAt(0,0,0);
        scene.add(rectLight);

        const spotLight = new THREE.SpotLight(0xffffff, 1, 20, Math.PI/6, 0.5);
        spotLight.position.set(0, 8, 0);
        spotLight.target.position.set(0, 0, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        // Part√≠culas ambientales
        createParticles();

        setupNetwork();
        setupInteractions();
        animate();
        
        addLog('SYSTEM', 'Sala HoloMeet VR inicializada');
    }

    function createParticles() {
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        
        for(let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 30;
            positions[i + 1] = Math.random() * 5 + 0.5;
            positions[i + 2] = (Math.random() - 0.5) * 30;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0x00f3ff,
            size: 0.03,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geometry, material);
        particles.userData.velocities = [];
        
        for(let i = 0; i < particleCount; i++) {
            particles.userData.velocities.push({
                y: Math.random() * 0.005 + 0.002,
                x: (Math.random() - 0.5) * 0.002,
                z: (Math.random() - 0.5) * 0.002
            });
        }
        
        scene.add(particles);
        scene.userData.particles = particles;
    }

    // --- SISTEMA DE AVATARES ---
    function createAvatarMesh(id, color, name) {
        const group = new THREE.Group();
        
        const body = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.25, 0.8, 32),
            new THREE.MeshStandardMaterial({ 
                color: color, 
                metalness: 0.6, 
                roughness: 0.3,
                emissive: color,
                emissiveIntensity: 0.2
            })
        );
        body.position.y = 0.4;
        group.add(body);
        
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.18, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xffe4c4, metalness: 0.1, roughness: 0.6 })
        );
        head.position.y = 1.1;
        group.add(head);
        
        const ring = new THREE.Mesh(
            new THREE.TorusGeometry(0.35, 0.015, 8, 64),
            new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.8 })
        );
        ring.rotation.x = Math.PI / 2;
        ring.position.y = 0.15;
        group.add(ring);
        group.userData.ring = ring;
        
        const speakingIndicator = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 16, 16),
            new THREE.MeshBasicMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0,
                depthTest: false
            })
        );
        speakingIndicator.position.y = 1.5;
        speakingIndicator.renderOrder = 999;
        group.add(speakingIndicator);
        group.userData.speakingIndicator = speakingIndicator;
        
        // Etiqueta con nombre
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 48;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.roundRect(0, 0, 256, 48, 8);
        ctx.fill();
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(name, 128, 32);
        
        const tex = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(
            new THREE.SpriteMaterial({ map: tex, transparent: true })
        );
        sprite.scale.set(1.5, 0.3, 1);
        sprite.position.y = 1.6;
        group.add(sprite);
        
        return group;
    }

    function updateRemoteAvatar(id, data) {
        if(!remoteAvatars[id]) {
            const avatar = createAvatarMesh(id, data.color || '#00f3ff', data.name || 'Usuario');
            scene.add(avatar);
            remoteAvatars[id] = avatar;
            updateCount();
            addLog('RED', `${data.name || 'Usuario'} se uni√≥`);
        }
        
        const avatar = remoteAvatars[id];
        avatar.position.set(data.x, data.y, data.z);
        avatar.rotation.y = data.rotY || 0;
        
        if(avatar.userData.speakingIndicator) {
            avatar.userData.speakingIndicator.material.opacity = data.isSpeaking ? 0.8 : 0;
        }
        
        if(avatar.userData.ring) {
            avatar.userData.ring.rotation.z += 0.02;
        }
    }

    function updateCount() {
        const count = Object.keys(remoteAvatars).length + 1;
        document.getElementById('user-count').innerHTML = `üë• ${count} participante${count > 1 ? 's' : ''}`;
    }

    // --- L√ìGICA DE RED (HOST/CLIENT) ---
    function setupNetwork() {
        document.getElementById('room-id').innerText = `ID: ${roomName}`;

        peer = new Peer(ROOM_ID);

        peer.on('open', () => {
            isHost = true;
            updateStatus('HOST (MODERADOR)', '#00ff00');
            document.getElementById('mute-all-btn').disabled = false;
            addLog('RED', 'Sala creada. Esperando participantes...');
        });

        peer.on('error', (err) => {
            if(err.type === 'unavailable-id') {
                isHost = false;
                updateStatus('CLIENTE (GUEST)', '#00f3ff');
                connectAsGuest(ROOM_ID);
            } else {
                addLog('ERROR', `Red: ${err.type}`);
            }
        });

        peer.on('connection', (conn) => {
            setupConnEvents(conn);
            if(isHost) {
                clientConns.push(conn);
                updateCount();
                addLog('RED', 'Participante conectado.');
                if(pdfDoc || youtubeVideoId) {
                    setTimeout(() => {
                        if(youtubeVideoId) conn.send({ type: 'youtube', videoId: youtubeVideoId });
                        if(pdfDoc) conn.send({ type: 'sync-pdf', page: pageNum });
                    }, 1000);
                }
            }
        });
    }

    function connectAsGuest(hostId) {
        const guestPeer = new Peer();
        guestPeer.on('open', () => {
            myConn = guestPeer.connect(hostId);
            setupConnEvents(myConn);
            addLog('RED', 'Conectando como invitado...');
        });
        guestPeer.on('error', (err) => {
            addLog('ERROR', `Conexi√≥n: ${err.type}`);
        });
    }

    function setupConnEvents(conn) {
        conn.on('open', () => {
            addLog('RED', 'Conectado a la sala');
            broadcast({ 
                type: 'avatar-pos', 
                x: camera.position.x, 
                y: camera.position.y, 
                z: camera.position.z,
                name: 'Participante'
            });
        });
        
        conn.on('data', (data) => {
            handleData(data);
            if(isHost) clientConns.forEach(c => { if(c.peer !== conn.peer) c.send(data); });
        });
        conn.on('close', () => {
            if(isHost) {
                clientConns = clientConns.filter(c => c.peer !== conn.peer);
                updateCount();
            }
            if(remoteAvatars[conn.peer]) {
                scene.remove(remoteAvatars[conn.peer]);
                delete remoteAvatars[conn.peer];
                addLog('RED', 'Usuario desconectado');
            }
        });
    }

    function broadcast(data) {
        handleData(data);
        if(isHost) clientConns.forEach(c => c.send(data));
        else if(myConn) myConn.send(data);
    }

    function handleData(d) {
        switch(d.type) {
            case 'chat': 
                addLog('CHAT', `<b style="color:var(--neon)">${d.user}:</b> ${d.text}`);
                break;
            case 'laser': 
                laserPoint.position.copy(d.pos); 
                laserPoint.visible = true; 
                break;
            case 'laser-off': 
                laserPoint.visible = false; 
                break;
            case 'pdf-img': 
                updateDashboard(d.img, d.page); 
                break;
            case 'timer': 
                timeLeft = d.sec; 
                updateTimerDisplay(); 
                break;
            case 'sync-pdf': 
                pageNum = d.page; 
                document.getElementById('page-num').innerText = `PAG ${pageNum} / ${pdfDoc ? pdfDoc.numPages : 1}`;
                break;
            case 'avatar-pos':
                updateRemoteAvatar(d.id || Date.now().toString(), { x: d.x, y: d.y, z: d.z, name: d.name, color: d.color, rotY: d.rotY, isSpeaking: d.isSpeaking });
                break;
            case 'youtube':
                loadYouTubeVideo(d.videoId);
                addLog('VIDEO', `YouTube: ${d.videoId}`);
                break;
            case 'mute-all':
                handleMuteAll(d.muted);
                break;
            case 'speaking':
                if(d.id && remoteAvatars[d.id] && remoteAvatars[d.id].userData.speakingIndicator) {
                    remoteAvatars[d.id].userData.speakingIndicator.material.opacity = d.isSpeaking ? 0.8 : 0;
                }
                break;
        }
    }

    function updateStatus(status, color) {
        document.getElementById('role-tag').innerText = status;
        document.getElementById('role-tag').style.color = color;
    }

    // --- PDF HD ---
    async function renderPDF() {
        if(!pdfDoc) return;
        const page = await pdfDoc.getPage(pageNum);
        const canvas = document.getElementById('pdf-canvas');
        const ctx = canvas.getContext('2d');
        const viewport = page.getViewport({ scale: 3 }); // CALIDAD HD
        canvas.width = viewport.width; canvas.height = viewport.height;
        
        await page.render({ canvasContext: ctx, viewport }).promise;
        const img = canvas.toDataURL('image/jpeg', 0.85);
        
        updateDashboard(img, pageNum);
        broadcast({ type: 'pdf-img', img: img, page: pageNum });
    }

    function updateDashboard(img, pg) {
        new THREE.TextureLoader().load(img, tex => {
            dashboard.material.map = tex;
            dashboard.material.opacity = 1;
            dashboard.material.needsUpdate = true;
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            document.getElementById('page-num').innerText = `PAG ${pg} / ${pdfDoc ? pdfDoc.numPages : 1}`;
        });
    }

    function changePage(delta) {
        if(!pdfDoc) return;
        const newPage = Math.max(1, Math.min(pdfDoc.numPages, pageNum + delta));
        if(newPage !== pageNum) {
            pageNum = newPage;
            renderPDF();
            addLog('DOC', `P√°gina ${pageNum}`);
        }
    }

    document.getElementById('pdf-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = async function() {
            try {
                pdfDoc = await pdfjsLib.getDocument(new Uint8Array(this.result)).promise;
                pageNum = 1;
                renderPDF();
                addLog('DOC', `PDF: ${file.name}`);
                showNotification(`PDF cargado: ${file.name}`);
            } catch(e) { 
                addLog('ERROR', `PDF: ${e.message}`); 
            }
        };
        reader.readAsArrayBuffer(file);
    });

    // --- YOUTUBE ---
    function loadYT() {
        const url = document.getElementById('yt-url').value.trim();
        if(!url) return;
        
        const videoId = extractYouTubeId(url);
        if(!videoId) {
            addLog('ERROR', 'YouTube URL inv√°lida');
            return;
        }
        
        loadYouTubeVideo(videoId);
        broadcast({ type: 'youtube', videoId: videoId });
        addLog('VIDEO', `YouTube: ${videoId}`);
    }

    function extractYouTubeId(url) {
        const match = url.match(/(?:youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#&?]*)/);
        return match && match[1].length === 11 ? match[1] : null;
    }

    function loadYouTubeVideo(videoId) {
        youtubeVideoId = videoId;
        isYouTubeActive = false;
        document.body.classList.remove('youtube-active');
        
        const oldObj = scene.getObjectByName('youtube3d');
        if(oldObj) scene.remove(oldObj);
        
        if(dashboard.material.map) {
            dashboard.material.map.dispose();
            dashboard.material.map = null;
            dashboard.material.opacity = 0.15;
        }
        
        const div = document.createElement('div');
        div.style.cssText = 'width: 720px; height: 405px; background: #000; border-radius: 8px; overflow: hidden; position: relative;';
        
        const iframe = document.createElement('iframe');
        iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&enablejsapi=1`;
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
        
        iframe.onerror = function() {
            div.innerHTML = `
                <div class="yt-blocked-message">
                    <h3>‚ö†Ô∏è Video Bloqueado</h3>
                    <p>Este video tiene restringida su incrustaci√≥n. √Åbrelo directamente en YouTube.</p>
                    <button onclick="closeYouTube()">CERRAR</button>
                </div>
            `;
        };
        
        div.appendChild(iframe);
        
        const youtube3d = new THREE.CSS3DObject(div);
        youtube3d.name = 'youtube3d';
        youtube3d.position.set(0, 2.6, -3.98);
        youtube3d.scale.set(0.008, 0.008, 0.008);
        scene.add(youtube3d);
        
        isYouTubeActive = true;
        document.body.classList.add('youtube-active');
        
        addLog('VIDEO', `Cargado: ${videoId}`);
    }
    
    function closeYouTube() {
        const oldObj = scene.getObjectByName('youtube3d');
        if(oldObj) scene.remove(oldObj);
        youtubeVideoId = null;
        isYouTubeActive = false;
        document.body.classList.remove('youtube-active');
    }

    // --- INTERACCIONES ---
    function setupInteractions() {
        // L√°ser
        window.addEventListener('mousemove', (e) => {
            if(!pdfDoc && !youtubeVideoId) return;
            
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            
            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, camera);
            const hits = ray.intersectObject(dashboard);
            
            if(hits.length > 0) {
                const p = hits[0].point;
                p.z += 0.02;
                laserPoint.position.copy(p);
                laserPoint.visible = true;
                broadcast({ type: 'laser', pos: p });
            } else {
                laserPoint.visible = false;
                broadcast({ type: 'laser-off' });
            }
        });

        // Chat
        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if(e.key === 'Enter' && e.target.value) {
                const txt = e.target.value;
                broadcast({ type: 'chat', user: isHost ? 'HOST' : 'GUEST', text: txt });
                e.target.value = '';
            }
        });

        // Redimensionar
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- TIMER ---
    function sendTimer(min) {
        timeLeft = min * 60;
        broadcast({ type: 'timer', sec: timeLeft });
        addLog('TIMER', `${min} minutos`);
    }

    function updateTimerDisplay() {
        const m = Math.floor(timeLeft / 60);
        const s = timeLeft % 60;
        const display = document.getElementById('timer-display');
        display.innerText = `${m}:${s.toString().padStart(2,'0')}`;
        display.style.color = timeLeft < 30 && timeLeft > 0 ? '#ff3333' : 'var(--neon)';
        display.style.textShadow = timeLeft < 30 && timeLeft > 0 ? '0 0 15px #ff0000' : '0 0 10px var(--neon)';
    }

    // --- AUDIO ---
    async function unlockAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if(audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            addLog('AUDIO', 'Contexto de audio desbloqueado');
        } catch(e) {
            addLog('AUDIO', 'Audio no disponible');
        }
    }

    function toggleMic() {
        if(!navigator.mediaDevices) {
            showNotification("Audio requiere HTTPS");
            return;
        }
        
        if(audioStream) {
            isMuted = !isMuted;
            const tracks = audioStream.getAudioTracks();
            tracks.forEach(track => track.enabled = !isMuted);
            
            const btn = document.getElementById('mic-btn');
            if(isMuted) {
                btn.textContent = 'üîá OFF';
                btn.style.background = '#ff4444';
                addLog('AUDIO', 'Silenciado');
            } else {
                btn.textContent = 'üé§ ON';
                btn.style.background = 'var(--neon-green)';
                addLog('AUDIO', 'Micr√≥fono activo');
            }
            
            broadcast({ type: 'speaking', id: peer.id, isSpeaking: !isMuted });
        } else {
            navigator.mediaDevices.getUserMedia({ audio: true, echoCancellation: true, noiseSuppression: true })
                .then(stream => {
                    audioStream = stream;
                    document.getElementById('mic-btn').textContent = 'üé§ ON';
                    document.getElementById('mic-btn').style.background = 'var(--neon-green)';
                    addLog('AUDIO', 'Micr√≥fono activado');
                    showNotification('Micr√≥fono activo');
                    setupVoiceDetection(stream);
                })
                .catch(e => {
                    addLog('ERROR', `Audio: ${e.message}`);
                });
        }
    }
    
    function setupVoiceDetection(stream) {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        let isSpeaking = false;
        
        function detect() {
            if(!audioStream || isMuted) {
                requestAnimationFrame(detect);
                return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const speaking = avg > 30 && !isMuted;
            
            if(speaking !== isSpeaking) {
                isSpeaking = speaking;
                broadcast({ type: 'speaking', id: peer.id, isSpeaking: speaking });
            }
            
            requestAnimationFrame(detect);
        }
        detect();
    }

    function toggleMuteAll() {
        if(!isHost) {
            showNotification('Solo el HOST puede silenciar');
            return;
        }
        
        isMuted = !isMuted;
        
        if(audioStream) {
            audioStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
        }
        
        const btn = document.getElementById('mic-btn');
        if(isMuted) {
            btn.textContent = 'üîá OFF';
            btn.style.background = '#ff4444';
        } else {
            btn.textContent = 'üé§ ON';
            btn.style.background = 'var(--neon-green)';
        }
        
        broadcast({ type: 'mute-all', muted: isMuted });
        addLog('AUDIO', isMuted ? 'Todos silenciados' : 'Audio activado');
    }
    
    function handleMuteAll(muted) {
        isMuted = muted;
        
        const btn = document.getElementById('mic-btn');
        if(isMuted) {
            btn.textContent = 'üîá OFF';
            btn.style.background = '#ff4444';
        } else {
            btn.textContent = 'üé§ ON';
            btn.style.background = 'var(--neon-green)';
        }
        
        if(audioStream) {
            audioStream.getAudioTracks().forEach(track => track.enabled = !isMuted);
        }
        
        addLog('AUDIO', muted ? 'Silenciado por HOST' : 'Audio restaurado');
    }

    function addLog(type, msg) {
        const t = new Date().toLocaleTimeString();
        logs.push(`[${t}] ${type}: ${msg}`);
        if(type === 'CHAT') {
            const div = document.createElement('div');
            div.innerHTML = `<span style="color:#666">${t}</span> ${msg}`;
            document.getElementById('messages').appendChild(div);
            document.getElementById('messages').scrollTop = 9999;
        }
    }

    function exportLog() {
        const blob = new Blob([logs.join('\n')], {type: 'text/plain'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `Log_${roomName}_${new Date().toISOString().substr(0,10)}.txt`;
        a.click();
        addLog('LOG', 'Exportado');
    }

    function showNotification(msg) {
        const notif = document.createElement('div');
        notif.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,243,255,0.95);color:#000;padding:15px 30px;border-radius:8px;font-weight:bold;z-index:200;box-shadow:0 0 30px rgba(0,243,255,0.5);';
        notif.textContent = msg;
        document.body.appendChild(notif);
        setTimeout(() => notif.remove(), 2500);
    }

    function startApp() {
        document.getElementById('welcome-modal').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        unlockAudio();
        init3D();
    }

    // Loop principal
    setInterval(() => {
        // Actualizar avatar local
        if(isHost || myConn) {
            broadcast({
                type: 'avatar-pos',
                id: peer.id,
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                rotY: camera.rotation.y,
                name: isHost ? 'HOST' : 'Participante',
                isSpeaking: audioStream && !isMuted
            });
        }
        
        // Timer
        if(timeLeft > 0) {
            timeLeft--;
            updateTimerDisplay();
            if(isHost && timeLeft > 0 && timeLeft % 10 === 0) {
                broadcast({ type: 'timer', sec: timeLeft });
            }
            if(timeLeft === 0) {
                addLog('TIMER', '¬°Tiempo agotado!');
                showNotification('¬°Tiempo agotado!');
            }
        }
        
        // Part√≠culas
        if(scene.userData.particles) {
            const particles = scene.userData.particles;
            const positions = particles.geometry.attributes.position.array;
            particles.userData.velocities.forEach((v, i) => {
                positions[i * 3 + 1] += v.y;
                if(positions[i * 3 + 1] > 5) {
                    positions[i * 3 + 1] = 0.5;
                    positions[i * 3] = (Math.random() - 0.5) * 30;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
                }
            });
            particles.geometry.attributes.position.needsUpdate = true;
        }
        
        // Animar anillos
        Object.values(remoteAvatars).forEach(avatar => {
            if(avatar.userData.ring) {
                avatar.userData.ring.rotation.z += 0.015;
            }
        });
    }, 1000);

    function animate() {
        requestAnimationFrame(animate);
        
        dashboard.position.y = 2.6 + Math.sin(Date.now() * 0.001) * 0.03;
        
        composer.render(scene, camera);
        cssRenderer.render(scene, camera);
    }
</script>
</body>
</html>
