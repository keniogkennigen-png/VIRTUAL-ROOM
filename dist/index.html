<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoloMeet VR - Full Featured Suite</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', monospace; color: #00f3ff; }
        
        #hud { position: fixed; inset: 0; pointer-events: none; padding: 20px; z-index: 100; display: flex; flex-direction: column; justify-content: space-between; }
        .panel { 
            background: rgba(5, 10, 20, 0.9); border: 1px solid #00f3ff; 
            padding: 15px; backdrop-filter: blur(10px); pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.15); border-radius: 4px;
        }
        
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; }
        .status-dot { width: 8px; height: 8px; background: #333; border-radius: 50%; display: inline-block; margin-right: 5px; box-shadow: 0 0 5px #333; transition: 0.3s; }
        .status-active { background: #00ff00; box-shadow: 0 0 8px #00ff00; }
        .status-speaking { background: #00ff00; box-shadow: 0 0 15px #00ff00; animation: speakingPulse 0.5s infinite; }
        
        @keyframes speakingPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.8; }
        }
        
        #chat-box { width: 320px; height: 220px; display: flex; flex-direction: column; }
        #messages { flex: 1; overflow-y: auto; font-size: 11px; margin-bottom: 8px; color: #ccc; scrollbar-width: thin; }
        #messages div { margin-bottom: 4px; word-wrap: break-word; }
        
        .controls { display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap; }
        button { 
            background: rgba(0, 243, 255, 0.1); color: #00f3ff; border: 1px solid #00f3ff; 
            padding: 8px 16px; cursor: pointer; text-transform: uppercase; font-weight: bold; font-size: 11px;
            transition: all 0.2s;
        }
        button:hover { background: #00f3ff; color: #000; box-shadow: 0 0 15px #00f3ff; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .timer-warning { color: #ff3333 !important; text-shadow: 0 0 15px #ff0000 !important; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        input[type="text"] { background: #000; border: 1px solid #333; color: #fff; padding: 6px; border-radius: 3px; }
        input[type="text"]:focus { border-color: #00f3ff; outline: none; }
        
        #timer-display { font-size: 24px; font-weight: bold; text-align: center; margin: 5px 0; letter-spacing: 2px; }
        #pdf-canvas { display: none; }
        .yt-container { width: 720px; height: 405px; background: #000; border-radius: 8px; overflow: hidden; position: relative; }
        .yt-container iframe { width: 100%; height: 100%; border: none; }
        
        /* Modal de Bienvenida */
        #welcome-modal {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.95); z-index: 1000;
            display: flex; align-items: center; justify-content: center;
        }
        #welcome-modal.hidden { display: none; }
        .welcome-content {
            background: rgba(5, 10, 20, 0.95); border: 2px solid #00f3ff;
            padding: 40px; max-width: 500px; text-align: center;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.3); border-radius: 8px;
        }
        .welcome-content h1 { color: #00f3ff; margin-bottom: 20px; font-size: 28px; }
        .welcome-content p { color: #ccc; margin-bottom: 15px; line-height: 1.6; text-align: left; }
        .welcome-content ul { color: #ccc; text-align: left; margin-bottom: 25px; padding-left: 20px; }
        .welcome-content li { margin-bottom: 8px; }
        #enter-btn {
            background: linear-gradient(135deg, #00f3ff, #0088ff); color: #000;
            padding: 15px 40px; font-size: 16px; border: none;
        }
        #enter-btn:hover { box-shadow: 0 0 30px #00f3ff; transform: scale(1.05); }
        
        /* Error de YouTube bloqueado */
        .yt-blocked-message {
            position: absolute; inset: 0; background: rgba(20, 20, 20, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #ff6b6b; text-align: center; padding: 20px;
        }
        .yt-blocked-message h3 { color: #ff6b6b; margin-bottom: 15px; }
        .yt-blocked-message p { color: #ccc; max-width: 400px; line-height: 1.5; }
        .yt-blocked-message .try-again {
            margin-top: 20px; background: #ff6b6b; color: #000; border: none; padding: 10px 25px;
        }
        
        /* Indicador de hablando en avatar */
        .speaking-indicator {
            position: absolute; width: 20px; height: 20px;
            background: #00ff00; border-radius: 50%;
            box-shadow: 0 0 15px #00ff00; animation: speakingPulse 0.5s infinite;
            pointer-events: none; display: none;
        }
        
        /* Cursor interactivo para YouTube */
        .youtube-active .webgl-canvas { pointer-events: none !important; }
        .youtube-active .css3d-canvas { pointer-events: auto !important; }
    </style>
</head>
<body>

<!-- Modal de Bienvenida -->
<div id="welcome-modal">
    <div class="welcome-content">
        <h1>üé¨ HoloMeet VR</h1>
        <p>Bienvenido a la sala de videoconferencias inmersiva. Antes de continuar, ten en cuenta:</p>
        <ul>
            <li>üé§ Usa auriculares para evitar eco y feedback de audio</li>
            <li>üåê Comparte el ID de sala con tus participantes</li>
            <li>üì∫ Para videos de YouTube, usa enlaces p√∫blicos</li>
            <li>‚è∞ Usa el temporizador para gestionar turnos de palabra</li>
        </ul>
        <button id="enter-btn" onclick="enterRoom()">ENTRAR A LA SALA</button>
    </div>
</div>

<div id="hud">
    <div class="top-bar">
        <div class="panel">
            <div style="font-size: 10px; opacity: 0.6; margin-bottom: 5px;">ESTADO DE RED</div>
            <div style="font-size: 14px; display: flex; align-items: center;">
                <div id="net-status" class="status-dot"></div>
                <span id="role-display">CONECTANDO...</span>
            </div>
            <div id="room-id-display" style="font-size: 11px; margin-top: 5px; color: #888;"></div>
            <div id="utc-clock" style="font-size: 11px; margin-top: 5px; font-family: monospace;"></div>
            <div id="participants" style="font-size: 11px; margin-top: 5px; color: #00f3ff;">üë• 1 participante</div>
        </div>

        <div class="panel" style="text-align: center;">
            <div style="font-size: 10px;">TIEMPO DE SESI√ìN</div>
            <div id="timer-display">00:00</div>
            <div style="display:flex; gap:5px; justify-content:center; margin-top:5px;">
                <button onclick="setTimer(5)">5 MIN</button>
                <button onclick="setTimer(10)">10 MIN</button>
                <button onclick="setTimer(15)">15 MIN</button>
            </div>
        </div>

        <div id="chat-box" class="panel">
            <div id="messages"></div>
            <input type="text" id="chat-input" placeholder="Mensaje...">
        </div>
    </div>

    <div class="controls panel">
        <input type="file" id="pdf-upload" accept=".pdf" style="display:none">
        <button onclick="document.getElementById('pdf-upload').click()">üìÇ PDF</button>
        
        <div style="display: flex; gap: 5px; align-items: center; border-left: 1px solid #333; padding-left: 10px;">
            <button onclick="changePage(-1)">‚óÄ</button>
            <span id="page-display" style="font-size: 12px; min-width: 50px; text-align: center;">PAG 1</span>
            <button onclick="changePage(1)">‚ñ∂</button>
        </div>

        <div style="display:flex; gap:5px; border-left: 1px solid #333; padding-left: 10px;">
            <input type="text" id="yt-url" placeholder="YouTube URL" style="width: 180px;">
            <button onclick="loadYouTube()">‚ñ∂ YT</button>
        </div>

        <div style="border-left: 1px solid #333; padding-left: 10px;">
            <button id="mic-btn" onclick="toggleMic()">üé§ OFF</button>
        </div>
        
        <button id="mute-all-btn" onclick="toggleMuteAll()" style="border-color: #ff8800; color: #ff8800;">üîá SILENCIAR</button>
        
        <button onclick="exportLog()" style="border-color: #ff4444; color: #ff4444;">üíæ LOG</button>
    </div>
</div>

<canvas id="pdf-canvas"></canvas>

<script>
    // --- VARIABLES GLOBALES ---
    let scene, camera, renderer, cssRenderer, dashboard, laserPoint;
    let peer, myConnection = null, isHost = false;
    let clientConnections = [], remoteAvatars = {};
    let pdfDoc = null, pageNum = 1, youtubeVideoId = null;
    let logs = [], timerInterval, timeLeft = 0;
    let audioContext = null, audioStream = null, isMuted = false;
    let audioContextUnlocked = false;
    let isYouTubeActive = false;
    
    // Configuraci√≥n de Sala
    const urlParams = new URLSearchParams(window.location.search);
    const roomName = urlParams.get('room') || 'DEMO';
    const ROOM_ID = 'HM-VR-FULL-' + roomName;

    // --- MODAL DE BIENVENIDA ---
    function enterRoom() {
        document.getElementById('welcome-modal').classList.add('hidden');
        
        // Desbloquear contexto de audio del navegador
        unlockAudioContext();
        
        // Inicializar la aplicaci√≥n 3D
        init();
    }

    async function unlockAudioContext() {
        try {
            // Crear contexto de audio y suspenderlo inicialmente
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Intentar desbloquear con un sonidoÂæàÁü≠
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            audioContextUnlocked = true;
            addLog('AUDIO', 'Contexto de audio desbloqueado');
        } catch (e) {
            console.log('Audio context no disponible:', e);
            addLog('AUDIO', 'Audio no disponible en este navegador');
        }
    }

    function addLog(type, msg) {
        const t = new Date().toLocaleTimeString();
        logs.push(`[${t}] ${type}: ${msg}`);
        if(type === 'CHAT') {
            const div = document.createElement('div');
            div.innerHTML = `<span style="color: #666;">${t}</span> ${msg}`;
            document.getElementById('messages').appendChild(div);
            document.getElementById('messages').scrollTop = 9999;
        }
    }

    // --- INICIALIZACI√ìN 3D COMPLETA ---
    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x020205, 5, 25);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 8);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.domElement.classList.add('webgl-canvas');
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(renderer.domElement);

        // CSS3D Renderer para YouTube
        cssRenderer = new THREE.CSS3DRenderer();
        cssRenderer.setSize(window.innerWidth, window.innerHeight);
        cssRenderer.domElement.classList.add('css3d-canvas');
        cssRenderer.domElement.style.position = 'absolute';
        cssRenderer.domElement.style.top = '0';
        cssRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(cssRenderer.domElement);

        // Suelo PBR mejorado
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 60),
            new THREE.MeshPhysicalMaterial({ 
                color: 0x080808, 
                metalness: 0.85, 
                roughness: 0.15, 
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Dashboard (Pantalla)
        dashboard = new THREE.Mesh(
            new THREE.PlaneGeometry(7, 4),
            new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
        );
        dashboard.position.set(0, 2.8, -5);
        scene.add(dashboard);

        // Marco de la pantalla
        const frameGeo = new THREE.BoxGeometry(7.4, 4.4, 0.1);
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.2 });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.set(0, 2.8, -5.1);
        scene.add(frame);

        // Soporte de pantalla
        const standBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.6, 0.1, 32),
            frameMat
        );
        standBase.position.set(0, 0.05, -4.5);
        scene.add(standBase);
        
        const standPole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 2.5, 16),
            new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.3 })
        );
        standPole.position.set(0, 1.3, -4.5);
        scene.add(standPole);

        // Puntero L√°ser
        laserPoint = new THREE.Mesh(
            new THREE.SphereGeometry(0.05), 
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        laserPoint.visible = false;
        scene.add(laserPoint);

        // Iluminaci√≥n profesional
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
        scene.add(ambientLight);

        const rectLight = new THREE.RectAreaLight(0x00f3ff, 8, 12, 8);
        rectLight.position.set(0, 6, -2);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);

        const spotLight = new THREE.SpotLight(0xffffff, 2, 20, Math.PI / 6, 0.5);
        spotLight.position.set(0, 8, 0);
        spotLight.target.position.set(0, 0, 0);
        spotLight.castShadow = true;
        scene.add(spotLight);
        scene.add(spotLight.target);

        // Part√≠culas ambientales
        createParticles();

        initNetwork();
        setupInputs();
        animate();
        
        addLog('SYSTEM', 'Sala HoloMeet VR inicializada');
    }

    // --- SISTEMA DE AVATARES ---
    function createAvatarMesh(id, color, name) {
        const group = new THREE.Group();
        
        // Cuerpo (cilindro)
        const body = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.25, 0.8, 32),
            new THREE.MeshStandardMaterial({ 
                color: color, 
                metalness: 0.6, 
                roughness: 0.3,
                emissive: color,
                emissiveIntensity: 0.2
            })
        );
        body.position.y = 0.4;
        group.add(body);
        
        // Cabeza (esfera)
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.18, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xffe4c4, metalness: 0.1, roughness: 0.6 })
        );
        head.position.y = 1.1;
        group.add(head);
        
        // Indicador de participaci√≥n (anillo)
        const ring = new THREE.Mesh(
            new THREE.TorusGeometry(0.35, 0.015, 8, 64),
            new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.8 })
        );
        ring.rotation.x = Math.PI / 2;
        ring.position.y = 0.15;
        group.add(ring);
        group.userData.ring = ring;
        
        // Indicador de hablando (esfera sobre la cabeza)
        const speakingIndicator = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 16, 16),
            new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0,
                depthTest: false
            })
        );
        speakingIndicator.position.y = 1.5;
        speakingIndicator.renderOrder = 999;
        group.add(speakingIndicator);
        group.userData.speakingIndicator = speakingIndicator;
        
        // Etiqueta con nombre
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 48;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.roundRect(0, 0, 256, 48, 8);
        ctx.fill();
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(name, 128, 32);
        
        const tex = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(
            new THREE.SpriteMaterial({ map: tex, transparent: true })
        );
        sprite.scale.set(1.5, 0.3, 1);
        sprite.position.y = 1.6;
        group.add(sprite);
        
        return group;
    }

    function updateRemoteAvatar(id, data) {
        if(!remoteAvatars[id]) {
            const avatar = createAvatarMesh(id, data.color || '#00f3ff', data.name || 'Usuario');
            scene.add(avatar);
            remoteAvatars[id] = avatar;
            updateParticipantCount();
            addLog('RED', `${data.name || 'Usuario'} se uni√≥`);
        }
        
        const avatar = remoteAvatars[id];
        avatar.position.set(data.x, data.y, data.z);
        avatar.rotation.y = data.rotY || 0;
        
        // Actualizar indicador de hablando
        if(avatar.userData.speakingIndicator) {
            avatar.userData.speakingIndicator.material.opacity = data.isSpeaking ? 0.8 : 0;
        }
        
        // Animar anillo
        if(avatar.userData.ring) {
            avatar.userData.ring.rotation.z += 0.02;
        }
    }

    function removeRemoteAvatar(id) {
        if(remoteAvatars[id]) {
            scene.remove(remoteAvatars[id]);
            delete remoteAvatars[id];
            updateParticipantCount();
            addLog('RED', 'Usuario desconectado');
        }
    }

    function updateParticipantCount() {
        const count = Object.keys(remoteAvatars).length + 1;
        document.getElementById('participants').innerHTML = `üë• ${count} participante${count > 1 ? 's' : ''}`;
    }

    function createParticles() {
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        
        for(let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 30;
            positions[i + 1] = Math.random() * 5 + 0.5;
            positions[i + 2] = (Math.random() - 0.5) * 30;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0x00f3ff,
            size: 0.03,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geometry, material);
        particles.userData.velocities = [];
        
        for(let i = 0; i < particleCount; i++) {
            particles.userData.velocities.push({
                y: Math.random() * 0.005 + 0.002,
                x: (Math.random() - 0.5) * 0.002,
                z: (Math.random() - 0.5) * 0.002
            });
        }
        
        scene.add(particles);
        scene.userData.particles = particles;
    }

    // --- L√ìGICA DE RED ---
    function initNetwork() {
        document.getElementById('room-id-display').innerText = `ID: ${roomName}`;
        
        peer = new Peer(ROOM_ID);

        peer.on('open', (id) => {
            isHost = true;
            document.getElementById('role-display').innerText = "HOST (SERVIDOR)";
            document.getElementById('role-display').style.color = "#00ff00";
            document.getElementById('net-status').classList.add('status-active');
            addLog('RED', 'Sala creada. Esperando participantes...');
            
            // Habilitar bot√≥n de mute all solo para host
            document.getElementById('mute-all-btn').disabled = false;
        });

        peer.on('error', (err) => {
            if (err.type === 'unavailable-id') {
                document.getElementById('role-display').innerText = "CLIENTE (GUEST)";
                document.getElementById('role-display').style.color = "#00f3ff";
                addLog('RED', 'Conectando como invitado...');
                connectAsGuest();
            } else {
                addLog('ERROR', `Red: ${err.type}`);
            }
        });

        peer.on('connection', (conn) => {
            setupConnection(conn);
            if(isHost) {
                clientConnections.push(conn);
                addLog('RED', 'Participante conectado.');
                // Sincronizar estado actual
                if(pdfDoc || youtubeVideoId) {
                    setTimeout(() => {
                        if(youtubeVideoId) sendTo(conn, { type: 'youtube', videoId: youtubeVideoId });
                        if(pdfDoc) sendTo(conn, { type: 'sync-state', page: pageNum });
                    }, 1000);
                }
            }
        });
    }

    function connectAsGuest() {
        peer = new Peer();
        peer.on('open', () => {
            const conn = peer.connect(ROOM_ID);
            setupConnection(conn);
            myConnection = conn;
        });
        peer.on('error', (err) => {
            addLog('ERROR', `Conexi√≥n: ${err.type}`);
        });
    }

    function setupConnection(conn) {
        conn.on('open', () => {
            document.getElementById('net-status').classList.add('status-active');
            addLog('RED', 'Conectado a la sala');
            // Enviar mi posici√≥n inicial
            broadcast({ 
                type: 'avatar-pos', 
                x: camera.position.x, 
                y: camera.position.y, 
                z: camera.position.z,
                name: 'Participante'
            });
        });

        conn.on('data', (data) => {
            handleData(data);
            if (isHost) {
                clientConnections.forEach(c => {
                    if (c.peer !== conn.peer) c.send(data);
                });
            }
        });
        
        conn.on('close', () => {
            if(isHost) {
                clientConnections = clientConnections.filter(c => c.peer !== conn.peer);
            }
            removeRemoteAvatar(conn.peer);
        });
    }

    function broadcast(data) {
        handleData(data);
        if (isHost) {
            clientConnections.forEach(c => c.send(data));
        } else if (myConnection) {
            myConnection.send(data);
        }
    }
    
    function sendTo(conn, data) {
        conn.send(data);
    }

    function handleData(data) {
        switch(data.type) {
            case 'chat': 
                addLog('CHAT', `<b style="color:#00f3ff">${data.user}:</b> ${data.text}`);
                break;
            case 'laser':
                laserPoint.position.copy(data.pos);
                laserPoint.position.z += 0.02;
                laserPoint.visible = true;
                break;
            case 'laser-off':
                laserPoint.visible = false;
                break;
            case 'pdf-img':
                updateDashboard(data.img);
                break;
            case 'set-page':
                pageNum = data.page;
                document.getElementById('page-display').innerText = `PAG ${pageNum}`;
                break;
            case 'timer':
                timeLeft = data.seconds;
                updateTimerDisplay();
                break;
            case 'sync-state':
                pageNum = data.page;
                document.getElementById('page-display').innerText = `PAG ${pageNum}`;
                addLog('SYNC', `P√°gina ${pageNum}`);
                break;
            case 'avatar-pos':
                updateRemoteAvatar(data.id || Date.now().toString(), { x: data.x, y: data.y, z: data.z, name: data.name, color: data.color, rotY: data.rotY, isSpeaking: data.isSpeaking });
                break;
            case 'youtube':
                loadYouTubeVideo(data.videoId);
                addLog('VIDEO', `YouTube: ${data.videoId}`);
                break;
            case 'mute-all':
                handleMuteAll(data.muted);
                break;
            case 'speaking':
                // Actualizar indicador de hablando
                if(data.id && remoteAvatars[data.id] && remoteAvatars[data.id].userData.speakingIndicator) {
                    remoteAvatars[data.id].userData.speakingIndicator.material.opacity = data.isSpeaking ? 0.8 : 0;
                }
                break;
        }
    }

    // --- PDF DE ALTA CALIDAD ---
    async function renderPage() {
        if(!pdfDoc) return;
        const page = await pdfDoc.getPage(pageNum);
        const canvas = document.getElementById('pdf-canvas');
        const ctx = canvas.getContext('2d');
        
        // ALTA RESOLUCI√ìN para PDFs n√≠tidos
        const scale = 4; // Mayor escala = mejor calidad
        const viewport = page.getViewport({ scale });
        
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        
        await page.render({ 
            canvasContext: ctx, 
            viewport: viewport 
        }).promise;
        
        const imgData = canvas.toDataURL('image/jpeg', 0.85);
        
        updateDashboard(imgData);
        document.getElementById('page-display').innerText = `PAG ${pageNum}`;
        
        broadcast({ type: 'pdf-img', img: imgData });
    }

    function changePage(delta) {
        if(!pdfDoc) return;
        const newPage = Math.max(1, Math.min(pdfDoc.numPages, pageNum + delta));
        if(newPage !== pageNum) {
            pageNum = newPage;
            renderPage();
            addLog('DOC', `P√°gina ${pageNum}`);
        }
    }

    function updateDashboard(img) {
        new THREE.TextureLoader().load(img, (tex) => {
            dashboard.material.map = tex;
            dashboard.material.opacity = 1;
            dashboard.material.needsUpdate = true;
            
            // Configurar filtros para nitidez
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        });
    }

    document.getElementById('pdf-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = async function() {
            try {
                pdfDoc = await pdfjsLib.getDocument(new Uint8Array(this.result)).promise;
                pageNum = 1;
                renderPage();
                addLog('DOC', `PDF: ${file.name}`);
                showNotification(`PDF cargado: ${file.name}`);
            } catch(e) { 
                addLog('ERROR', `PDF: ${e.message}`); 
            }
        };
        reader.readAsArrayBuffer(file);
    });

    // --- YOUTUBE ---
    function loadYouTube() {
        const url = document.getElementById('yt-url').value.trim();
        if(!url) return;
        
        const videoId = extractYouTubeId(url);
        if(!videoId) {
            addLog('ERROR', 'YouTube URL inv√°lida');
            return;
        }
        
        loadYouTubeVideo(videoId);
        broadcast({ type: 'youtube', videoId: videoId });
        addLog('VIDEO', `YouTube: ${videoId}`);
    }

    function extractYouTubeId(url) {
        const match = url.match(/(?:youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#&?]*)/);
        return match && match[1].length === 11 ? match[1] : null;
    }

    function loadYouTubeVideo(videoId) {
        youtubeVideoId = videoId;
        
        // Desactivar YouTube anterior
        isYouTubeActive = false;
        document.body.classList.remove('youtube-active');
        
        // Remover YouTube anterior
        const oldObj = scene.getObjectByName('youtube3d');
        if(oldObj) scene.remove(oldObj);
        
        // Remover PDF
        if(dashboard.material.map) {
            dashboard.material.map.dispose();
            dashboard.material.map = null;
            dashboard.material.opacity = 0.15;
        }
        
        // Crear elemento YouTube
        const div = document.createElement('div');
        div.className = 'yt-container';
        
        // Crear iframe con manejo de errores
        const iframe = document.createElement('iframe');
        iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&enablejsapi=1`;
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        
        // Manejar error de X-Frame-Options
        iframe.onload = function() {
            // Verificar si el iframe se carg√≥ correctamente
            try {
                // Si el contenido es accesible, verificar si hay un mensaje de error
                if (iframe.contentDocument && iframe.contentDocument.body) {
                    const bodyText = iframe.contentDocument.body.textContent || '';
                    if (bodyText.includes('This video is not available') || 
                        bodyText.includes('restringida') ||
                        bodyText.includes('blocked')) {
                        showYouTubeBlockedMessage(div);
                    }
                }
            } catch (e) {
                // Cross-origin, probablemente est√° bloqueado
                console.log('No se puede acceder al contenido del iframe');
            }
        };
        
        iframe.onerror = function() {
            showYouTubeBlockedMessage(div);
        };
        
        div.appendChild(iframe);
        
        const youtube3d = new THREE.CSS3DObject(div);
        youtube3d.name = 'youtube3d';
        youtube3d.position.set(0, 2.8, -4.98);
        youtube3d.scale.set(0.008, 0.008, 0.008);
        scene.add(youtube3d);
        
        // Activar modo YouTube para permitir clics
        isYouTubeActive = true;
        document.body.classList.add('youtube-active');
        
        addLog('VIDEO', `Cargado: ${videoId}`);
    }
    
    function showYouTubeBlockedMessage(container) {
        // Limpiar el contenedor
        container.innerHTML = '';
        
        // Crear mensaje de error
        const msgDiv = document.createElement('div');
        msgDiv.className = 'yt-blocked-message';
        msgDiv.innerHTML = `
            <h3>‚ö†Ô∏è Video Bloqueado</h3>
            <p>Este video de YouTube tiene restringida su incrustaci√≥n (X-Frame-Options).</p>
            <p>Soluci√≥n: Abre el video directamente en YouTube o usa un video diferente.</p>
            <button class="try-again" onclick="closeYouTube()">CERRAR VIDEO</button>
        `;
        
        container.appendChild(msgDiv);
        addLog('VIDEO', 'Video bloqueado por restricciones de YouTube');
    }
    
    function closeYouTube() {
        const oldObj = scene.getObjectByName('youtube3d');
        if(oldObj) scene.remove(oldObj);
        youtubeVideoId = null;
        isYouTubeActive = false;
        document.body.classList.remove('youtube-active');
        addLog('VIDEO', 'Video cerrado');
    }

    // --- INTERACCIONES ---
    function setupInputs() {
        // L√°ser
        window.addEventListener('mousemove', (e) => {
            if(!pdfDoc && !youtubeVideoId) return;
            
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            
            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, camera);
            const hits = ray.intersectObject(dashboard);
            
            if(hits.length > 0) {
                const p = hits[0].point;
                p.z += 0.02;
                laserPoint.position.copy(p);
                laserPoint.visible = true;
                broadcast({ type: 'laser', pos: p });
            } else {
                laserPoint.visible = false;
                broadcast({ type: 'laser-off' });
            }
        });

        // Chat
        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if(e.key === 'Enter' && e.target.value) {
                const txt = e.target.value;
                broadcast({ type: 'chat', user: isHost ? 'HOST' : 'GUEST', text: txt });
                e.target.value = '';
            }
        });

        // Redimensionar
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- TIMER ---
    function setTimer(min) {
        timeLeft = min * 60;
        broadcast({ type: 'timer', seconds: timeLeft });
        addLog('TIMER', `${min} minutos`);
    }

    function updateTimerDisplay() {
        const m = Math.floor(timeLeft / 60);
        const s = timeLeft % 60;
        const display = document.getElementById('timer-display');
        display.innerText = `${m}:${s.toString().padStart(2,'0')}`;
        display.classList.toggle('timer-warning', timeLeft < 30 && timeLeft > 0);
    }

    setInterval(() => {
        // Actualizar posici√≥n del avatar local
        if(isHost || myConnection) {
            broadcast({
                type: 'avatar-pos',
                id: peer.id,
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                rotY: camera.rotation.y,
                name: isHost ? 'HOST' : 'Participante',
                isSpeaking: audioStream && !isMuted
            });
        }
        
        // Timer
        if(timeLeft > 0) {
            timeLeft--;
            updateTimerDisplay();
            if(isHost && timeLeft > 0 && timeLeft % 10 === 0) {
                broadcast({ type: 'timer', seconds: timeLeft });
            }
            if(timeLeft === 0) {
                addLog('TIMER', '¬°Tiempo agotado!');
                showNotification('¬°Tiempo agotado!');
            }
        }
        
        // Clock
        document.getElementById('utc-clock').innerText = new Date().toISOString().replace('T', ' ').substr(0, 19) + " UTC";
        
        // Part√≠culas
        if(scene.userData.particles) {
            const particles = scene.userData.particles;
            const positions = particles.geometry.attributes.position.array;
            particles.userData.velocities.forEach((v, i) => {
                positions[i * 3 + 1] += v.y;
                if(positions[i * 3 + 1] > 5) {
                    positions[i * 3 + 1] = 0.5;
                    positions[i * 3] = (Math.random() - 0.5) * 30;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
                }
            });
            particles.geometry.attributes.position.needsUpdate = true;
        }
    }, 1000);

    function exportLog() {
        const blob = new Blob([logs.join('\n')], {type: 'text/plain'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `Log_${roomName}_${new Date().toISOString().substr(0,10)}.txt`;
        a.click();
        addLog('LOG', 'Exportado');
        showNotification('Log descargado');
    }

    // --- AUDIO Y MUTE ---
    function toggleMic() {
        if(!navigator.mediaDevices) {
            showNotification("Audio requiere HTTPS");
            return;
        }
        
        if(audioStream) {
            // Silenciar/activar audio local
            isMuted = !isMuted;
            const tracks = audioStream.getAudioTracks();
            tracks.forEach(track => {
                track.enabled = !isMuted;
            });
            
            const btn = document.getElementById('mic-btn');
            if(isMuted) {
                btn.textContent = 'üîá OFF';
                btn.style.background = '#ff4444';
                addLog('AUDIO', 'Micr√≥fono silenciado');
            } else {
                btn.textContent = 'üé§ ON';
                btn.style.background = '#00ff88';
                addLog('AUDIO', 'Micr√≥fono activo');
            }
            
            // Actualizar estado de hablando
            broadcast({ type: 'speaking', id: peer.id, isSpeaking: !isMuted });
        } else {
            // Activar microphone por primera vez
            navigator.mediaDevices.getUserMedia({ audio: true, echoCancellation: true, noiseSuppression: true })
                .then(stream => {
                    audioStream = stream;
                    document.getElementById('mic-btn').textContent = 'üé§ ON';
                    document.getElementById('mic-btn').style.background = '#00ff88';
                    addLog('AUDIO', 'Micr√≥fono activado');
                    showNotification('Micr√≥fono activo');
                    
                    // Iniciar detecci√≥n de voz para indicar cuando est√° hablando
                    setupVoiceDetection(stream);
                })
                .catch(e => {
                    addLog('ERROR', `Audio: ${e.message}`);
                    showNotification('Error al activar micr√≥fono');
                });
        }
    }
    
    function setupVoiceDetection(stream) {
        // Analizador de audio para detectar voz
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        let isCurrentlySpeaking = false;
        
        function detectVoice() {
            if(!audioStream || isMuted) {
                requestAnimationFrame(detectVoice);
                return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            
            const threshold = 30;
            const nowSpeaking = average > threshold && !isMuted;
            
            if(nowSpeaking !== isCurrentlySpeaking) {
                isCurrentlySpeaking = nowSpeaking;
                broadcast({ type: 'speaking', id: peer.id, isSpeaking: nowSpeaking });
                
                // Actualizar indicador local
                if(remoteAvatars[peer.id] && remoteAvatars[peer.id].userData.speakingIndicator) {
                    remoteAvatars[peer.id].userData.speakingIndicator.material.opacity = nowSpeaking ? 0.8 : 0;
                }
            }
            
            requestAnimationFrame(detectVoice);
        }
        
        detectVoice();
    }

    function toggleMuteAll() {
        if(!isHost) {
            showNotification('Solo el HOST puede silenciar');
            return;
        }
        
        isMuted = !isMuted;
        
        // Silenciar microphone local
        if(audioStream) {
            const tracks = audioStream.getAudioTracks();
            tracks.forEach(track => {
                track.enabled = !isMuted;
            });
            
            const btn = document.getElementById('mic-btn');
            if(isMuted) {
                btn.textContent = 'üîá OFF';
                btn.style.background = '#ff4444';
            } else {
                btn.textContent = 'üé§ ON';
                btn.style.background = '#00ff88';
            }
        }
        
        // Enviar comando a todos los clientes
        broadcast({ type: 'mute-all', muted: isMuted });
        
        const status = isMuted ? 'TODOS SILENCIADOS' : 'AUDIO ACTIVADO';
        addLog('AUDIO', status);
        showNotification(status);
    }
    
    function handleMuteAll(muted) {
        isMuted = muted;
        
        // Actualizar bot√≥n local
        const btn = document.getElementById('mic-btn');
        if(isMuted) {
            btn.textContent = 'üîá OFF';
            btn.style.background = '#ff4444';
        } else {
            btn.textContent = 'üé§ ON';
            btn.style.background = '#00ff88';
        }
        
        // Silenciar microphone si existe
        if(audioStream) {
            const tracks = audioStream.getAudioTracks();
            tracks.forEach(track => {
                track.enabled = !isMuted;
            });
        }
        
        const status = muted ? 'Silenciado por HOST' : 'Audio restaurado';
        addLog('AUDIO', status);
        showNotification(status);
    }

    function showNotification(msg) {
        const notif = document.createElement('div');
        notif.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,243,255,0.95);color:#000;padding:15px 30px;border-radius:8px;font-weight:bold;z-index:200;box-shadow:0 0 30px rgba(0,243,255,0.5);';
        notif.textContent = msg;
        document.body.appendChild(notif);
        setTimeout(() => notif.remove(), 2500);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // Animaci√≥n flotante de la pantalla
        if(dashboard) {
            dashboard.position.y = 2.8 + Math.sin(Date.now() * 0.001) * 0.03;
        }
        
        // Animar l√°seres de otros usuarios
        Object.values(remoteAvatars).forEach(avatar => {
            if(avatar.userData.ring) {
                avatar.userData.ring.rotation.z += 0.015;
            }
        });
        
        renderer.render(scene, camera);
        cssRenderer.render(scene, camera);
    }

    // Desactivar el modal por defecto hasta que el usuario haga clic
    document.getElementById('welcome-modal').style.display = 'flex';
</script>
</body>
</html>
